<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
    <title>Document</title>
</head>
<body>
    <h1>Guia git- github</h1>
    <main>
        <section class="principal">
            <h2>Git</h2>
            <p><b>git = </b>Controle de versionamento.</p>
            <p><b>gitbash = </b>Suporte do software gitbash no CMD.</p>
            <article>
                <h3>Configuração gitbash no CMD</h3>
                <p><b>--global user.name"nome" = </b>Nome do usuário no github</p>
                <p><b>--global user.email"email" = </b>Email do usuário no github.</p>
                <p><b>git config --global --list = </b>verificar dados do gitbash.</p>
            </article>
            <section class="secundaria">
                <h3>Comando básicos CMD Gitbash</h3>
                <p><b></b>ctrk + l = </b> Limpar.</p>
                <p><b>ls = </b>Listar.</p>
                <p><b>cd = </b>Mudar repositório.</p>
                <p><b>cd .. = </b>Voltar ao repositório anterior.</p>
                <p><b>touch = </b>Criar novo arquivo.</p>
                <p><b>mkdir = </b>Criar novo repositório.</p>
                <p><b>rm = </b>Remover arquivo.</p>
                <p><b>rm -rf = </b>Remover pasta sem alerta de segurança (contém risco).</p>
                <p><b>mv = </b>Modver repositório para outra pasta.</p>
                <aside>Caso esteja na mesma pasta, apenas muda o nome do repositório. </aside>
                <p><b>git status = </b>Analisa em qual estágio do commit o documento esta.</p>
                <p><b>commit = </b>Cria um marco histórico a partir de qualquer alteração no código. Cada commit é rastreado por um ID que pode ser visitado ou até mesmo revertido possibilitando navegação entre diversas versões do seu código ao passar do tempo.</p>
                <article>   
                    <h4>Estágios do commit:</h4>
                    <p><b>MODFIED = </b>A partir que o codigo foi alterado entra no modo MODIFIED.</p>
                    <p><b>STAGING = </b>Quando o documento estiver pronto para ser commitado.</p>
                    <p><b>COMMITED = </b>Ariquivos enviados ao servidor .git.</p>
                </article>
                <p><b>git add. = </b> Altera TODOS o documento ao status STAGING.</p>
                <p><b>git add "nome do repositório" = </b>adicione o repositório específico ao modo STAGING.</p>
                <p><b>git rm --cached "mone do repositório" = </b> Retorna o diretório ao status  MODIFIED.</p>
                <p><b>git commit -m"mensagem" = </b>Commita os documentos ao servidor local git, adicionando uma descrição no commit.</p>
                <p><b>git log = </b>Analisa o históricode informações de commites do repositório.</p>
                <p><b>git log --oneline = </b>Históricode commites de forma compactada.</p>
                <h4>Revertendo commites.</h4>
                <p><b>chekout = </b>Forma mais segura de navegar pelos commites passados, possibilitando analisar as alterações feitas, ou até mesmo criar uma nova "branch"  a partir do ID do commite sugerido.</p>
                <aside> 
                    <p>O "Head" do documento será remetente ao ID sugerido.</p>
                    <p>para voltar a linha temporal atual usar o comando <b>git checkout "nome da branch"</b></p>
                </aside>
                <p><b>revert = </b>A partir do ID do commite sugerido, possibilita alterações do documento e do histórico, criando uma novo commite com seu próprio ID, revertendo parte do conteúdo do histórico.</p>
                <aside>Altera somente modificações do ID sugerido, sendo assim, não compromete os proximos commites, exibindo o histórico do REVERT.</aside>
                <p><b>reset = </b>Reverte o "HEAD" do documento ao ID especificado. (deleta os commites adiante).</p>
                <aside><p>Há possibilidade de resgatar alterações ao voltar no ID específico, porém o histórico dos commites adiante serão deletados. Para voltar ao ID sem alterações, basta usar o comando <br><b>git reset --hard</b>.</p></aside>
                <h4>Branch</h4>
                <p>diverge da linha principal de desenvolvimento e continua a trabalhar sem alterar o código Main, acaba com "pastas" com nome de diferentes versões do mesmo projeto, traz a segurança com o versionamento, além de otimizar o tempo quando trabalhado em grandes Features.</p>
                <p><b>git branch = </b>Lista se há branch no repositório.</p>
                <aside> O operador <b>*</b> identifica em qual branch estamos trabalhando.</aside>
                <p><b>git checkout "nome da branch" = </b>Cria uma nova branch, porém não a executa.</p>
                <p><b>git checkout -b "nome da branch" = </b>cria uma nova branch e executa em um comando.</p>
                <aside>
                    <p>Quando se trata de branch, o comando checkout tem a função escolher em qual branch iremos trabalhar. <br><b>git checkout (TAB) =</b> lista todas branch's presente no projeto.</p>
                </aside>
                <p><b>git branch -d "nome da branch" = </b>Deletar branch.</p>
                <aside>
                    <p>Observações de erros ao deletar branchs:</p>
                    <ul>
                        <li>não deve haver commites em andamento.</li>
                        <li>antes de deletar é necessário dar merge com a branch Main.</li>
                    </ul>
                <p>Caso deseja ignorar todos estes processos antes de deletar a branch, digite o comando <b>git branch -D "name branch"</b><br>(perderá qualquer alteração feita na branch selecionada). </p>
                </aside>
                <h5>Branch merge</h5>
                <p>Forma de mesclar o conteúdo de um branch (cópia) com a branch (master).</p>
                <p><b>git branch merge "nome da branch" = </b>Mesclando conteúdo da branch principal.</p>
                <aside>
                    <p>Obs.: para mesclar as branch's é necessário estarmos na branch de destino.</p>
                    <p><b>estudar 'Fast-forward' e 'Recursive' (timeline do HEAD do projeto)</b></p>
                </aside>
            </section>
        </section>
    
        <section class="principal">
            <h2>Github</h2>
            <p><b>Github = </b> É uma plataforma de hospedagem REMOTA de código-fonte e arquivos com controle de versionamento usando o Git.</p>
            <p><b>SSH = </b>Chave de segurança que valida o acesso e a gravação do código fonte no servidor remoto do github.</p>
            <aside>
                <p>É necessário validar e configurar sua chave SSH para ter acesso aos documentos remotos no github e também para publicar seus códigos na plataforma.</p>
            </aside>
            <p><b>abreviando SSH = </b> Para obtermos a chave SSH do projeto é necessário navegar pelo repositório de interesse no github, isso podeser um trabalho desgastante que demandará tempo. Portanto há possibilidade de abreviar tal chave no terminal do git bash para que toda vez que for publicar no github (push), no local do ID do SSH substituirmos pela palavra chave origin.</p>
            <article>
                <p>Abreviar o ID do SSH:</p>
                <p><b>git remote add origin "ID do SSH do diretório sugerido"</b></p>
                <p>verificar se o ID do SSH está funcionando: <b>git remote -v</b></p>
            </article>
            <p><b>git push "ID do SSH" = </b>Publicar documento no github.</p>
            <h3>Clonar repositório</h3>
            <p>Ao criar um repositório no GitHub, ele existirá como um repositório remoto. É possível clonar o repositório para criar uma cópia local no seu computador e sincronizar entre os dois locais. Caso não tenha o repositório desejado no servidor local(seu computador), é necessário fazer a clonagem do repositório remoto(github).</p>
            <p><b>git clone "ID do repositório desejado = "</b>Comando para clonar o repositório remoto no servidor local.</p>
            <aside>
                <p>Observar em qual pasta o repositório será clonado.<br>quando o repositório remoto é clonado, o ID do SSH já está abreviado (origin).</p>
            </aside>
            <h3>Pull Request</h3>
            <p>pull request no GitHub é uma maneira de sugerir alterações em um projeto de código aberto ou colaborativo. Essas alterações são propostas em um branch, que garante que o branch-padrão só contenha trabalho concluído e aprovado.</p>
            <h3>Fork</h3>
            <p>É um novo repositório que compartilha configurações de código e visibilidade com o repositório "upstream" original, ou seja, é uma forma de propor uma contribuição a um repositório existente.</p>
            <article>
                <h4>fazendo um Fork</h4>
                <ul>
                    <li>Primeiro, você precisa fazer um fork do repositório que deseja contribuir. Isso cria uma cópia do repositório na sua conta do GitHub.</li>
                    <li>Em seguida, clone o repositório forkado para sua máquina local.</li>
                    <li>Crie uma nova branch para suas alterações.</li>
                    <li>Trabalhe nas alterações que deseja fazer no código ou nos arquivos do projeto.</li>
                    <li>commite suas alterações.</li>
                    <li>Volte para o GitHub, vá até a sua branch e clique em "Pull Request" para enviar suas alterações para o repositório original.</li>
                </ul>
                <p>Após concluir alterações no repositório forkado, solicite sua contribuição ao autor do projeto original através do pull request.</p>
                <p>Caso sua contribuição seja satisfeita o criador do projeto poderá mesclar seu fork com seu branch principal.</p>
            </article>
            <h3>Readme.md</h3>
            <p>É um arquivo fundamental para qualquer repositório no GitHub, pois oferece informações importantes sobre o projeto.</p>
            <article>
              <h4>como estruturar um arquivo readme.md:</h4>
              <ul>
                <li>Nome do projeto</li>
                <li>Descrição = Uma breve descrição do que o projeto faz, a motivação por trás e quais tecnologias foram utilizadas.</li>
                <li>Instalação = Instruções sobre como instalar , configurar o ambiente de desenvolvimento e pré-requisitos.</li>
                <li>Instrução de uso = informar o usuário onde e como vai rodar o projeto.</li>
                <li>licenças =  orientações e permissões da forma como o usuário pode utilizar seu código.</li>
                <li>contribuição=  informa aos desenvolvedores sobre o que carece o projeto e o que pode ser contribuído e os códigos de conduta.</li>
                <li>contribuidores = reconhecimento aos contribuidores e facilita a comunicação entre os desenvolvedores que participaram do projeto.</li>
              </ul>  
            </article>
            <aside>
                <p><b>*pesquisar sobre templates de Readme para usar de base. <br>Para desenvolvedores front-end pode usar o Readme de forma mais criativa, utilizando links para visitar o site, gifs, prints do site para despertar curiosidade do usuário etc...</b></p>
            </aside>
        </section>
    </main>
    
</body>
</html>